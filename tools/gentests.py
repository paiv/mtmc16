#!/usr/bin/env python
import logging
import re
import readline
from pathlib import Path


logger = logging.getLogger(Path(__file__).name)


_DefaultSource = (
    (Path(__file__).parent.parent / 'mtmc').resolve()
        .relative_to(Path('.').resolve(), walk_up=True))


_DefaultDest = (
    (Path(__file__).parent.parent / 'src').resolve()
        .relative_to(Path('.').resolve(), walk_up=True))


def open_write(fn, exist_ok=False):
    if not exist_ok and fn.exists():
        print(str(fn))
        ans = input('file exists, overwrite? [yN]: ')
        if (not ans) or (ans not in 'Yy'): exit(1)
    return fn.open('w', encoding='utf-8')


def gen_emu_core(src, dest):
    ignore = 'testNoOp'.split()

    init = '''\
int MtmcExecutableLoad(FILE* file, struct MtmcExecutable* exe) {
    FatalError();
    return 1;
}

static struct Platform _platform = {};

static void _MtmcTestInit(struct MtmcEmu* emu) {
    PlatformInit(&_platform);
    emu->platform = &_platform;
    MtmcInitMemory(emu);
}\
'''

    head = '''// generated by gentests.py, do not edit
// {source}

#ifdef NDEBUG
#undef NDEBUG
#endif
#include <assert.h>

#define PAIV_MTMC_IMPLEMENTATION
#include "paiv_mtmc16.h"
#include "platform.c"

{init}

//\
'''.format(source=src.name, init=init)

    driver = '''
int main(int argc, const char* argv[]) {{
{tests}
    return 0;
}}\
'''
    text = src.read_text()
    names = re.findall(r'\s+@Test\s+void\s+(\w+)', text, flags=re.S)
    if ignore:
        gs = '|'.join(ignore)
        srx = r'(void (?:' + gs + r')\(\)\s*\{.*?\})'
        text = re.sub(srx, r'/*\n    \1\n    */', text, flags=re.S)
    text = re.sub(r'^.*?(?=public\s+class\b)', head, text, flags=re.S)
    text = re.sub(r'^\s*@Test\s*$', '', text, flags=re.M)
    text = re.sub(r'\bvoid\s+(\w+)\s*\(\s*\)', r'static void \1(void)', text)
    text = re.sub(r'assertEquals\(([^,]+?),\s*(.*?)\)', r'assert(\1 == \2)', text)
    text = re.sub(r'assertFalse\((.*?)\);', r'assert(\1 == 0);', text)
    text = re.sub(r'assertTrue\((.*?)\);', r'assert(\1 != 0);', text)
    text = re.sub(r'^(\s*)MonTanaMiniComputer\s+\w+\s+=\s+new\s+MonTanaMiniComputer\(\)',
        r'\1struct MtmcEmu emu = {0};\n\1_MtmcTestInit(&emu)', text, flags=re.S | re.M)
    text = re.sub(r'MonTanaMiniComputer\.ComputerStatus\.', 'MtmcEmuStatus_', text)
    text = re.sub(r'(computer\.\w+)\s*\(\s*\)', r'\1(&emu)', text)
    text = re.sub(r'(computer\.\w+)\s*\((?!&)', r'\1(&emu, ', text)
    text = re.sub(r'computer\.(\w)', lambda m:f'Mtmc{m[1].upper()}', text)
    text = re.sub(r'\}\s*$', '// }\n', text)
    text = re.sub(r'(?<=\d)_(?=\d)', '', text)
    text = re.sub(r'\(byte\)', '', text)
    text = re.sub(r'\bfalse\b', '0', text)
    text = re.sub(r'\btrue\b', '1', text)
    text = re.sub(r'MonTanaMiniComputer\.MEMORY_SIZE', 'Mtmc_MEMORY_SIZE', text)
    text = re.sub(r'\bWORD_SIZE\b', '2', text)

    print(text, file=dest)

    names = '\n'.join(f'    {p}{s}();' for s in names
        for p in [['', '// '][s in ignore]])
    s = driver.format(tests=names)
    print(s, file=dest)


def main(args):
    sroot = args.source / 'src/test/java/mtmc'
    droot = args.path

    sn = sroot / 'emulator/MonTanaMiniComputerTest.java'
    fn = droot / 'testmtmc16.c'
    with open_write(fn, args.overwrite) as fp:
        gen_emu_core(sn, fp)


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('-y', '--overwrite', action='store_true',
        help='overwrite files')
    parser.add_argument('-v', '--verbose', action='store_true',
        help='verbose output')
    parser.add_argument('-s', '--source', type=Path, default=_DefaultSource,
        help='MTMC-16 source root (default %(default)s)')
    parser.add_argument('-p', '--path', type=Path, default=_DefaultDest,
        help='destination path (default %(default)s)')
    args = parser.parse_args()

    level = logging.DEBUG if args.verbose else logging.WARN
    logging.basicConfig(level=level)

    main(args)
